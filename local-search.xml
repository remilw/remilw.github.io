<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>多态</title>
    <link href="/2022/09/11/%E5%A4%9A%E6%80%81/"/>
    <url>/2022/09/11/%E5%A4%9A%E6%80%81/</url>
    
    <content type="html"><![CDATA[<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>多态是指对不同的子类调用相同的方法，输出的结果不同。意思是程序在编译的时候并不知道要调用哪个类的方法，必须等到程序运行的时候才能决定。</p><h3 id="对象多态类型"><a href="#对象多态类型" class="headerlink" title="对象多态类型"></a>对象多态类型</h3><p>对象的多态类型一共有两种：静态类型，动态类型。静态类型是对类而言，在程序运行的过程为中，静态类型的类会根据引用对象的改变而改变。动态类型对对象而言，一但一个对象被new方法创建了，那这个对象就是内存中的有效的动态类型。</p><h4 id="检验动态类型的方法"><a href="#检验动态类型的方法" class="headerlink" title="检验动态类型的方法"></a>检验动态类型的方法</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash">public class Test &#123;<br>    public void exempleDeMecanismesTestantLeTypeDynamique(Object o) &#123;<br>      // o是对动态类型对象的引用<br>      // o可以是类A，类B<br>      // 或者是C的实例，或者D的实例<br><br>      //第一种方法 getClass<br>      System.out.println(o.getClass().getName() ) ;<br>      <span class="hljs-keyword">if</span> (o.getClass() == A.class) &#123;<br>        // 只有当o的动态类型是A的时候才会进入<span class="hljs-keyword">if</span><br>        ...<br>      &#125;<br><br>      // 第二种方法 instanceof<br>      <span class="hljs-keyword">if</span> (o instanceof A) &#123;<br>        //o是动态类型A或者A的子类<br>        ...<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs bash">public class A &#123;<br>    public String show(D obj) &#123;<br>        <span class="hljs-built_in">return</span> (<span class="hljs-string">&quot;A and D&quot;</span>);<br>    &#125;<br><br>    public String show(A obj) &#123;<br>        <span class="hljs-built_in">return</span> (<span class="hljs-string">&quot;A and A&quot;</span>);<br>    &#125; <br><br>&#125;<br><br>public class B extends A&#123;<br>    public String show(B obj)&#123;<br>        <span class="hljs-built_in">return</span> (<span class="hljs-string">&quot;B and B&quot;</span>);<br>    &#125;<br>    <br>    public String show(A obj)&#123;<br>        <span class="hljs-built_in">return</span> (<span class="hljs-string">&quot;B and A&quot;</span>);<br>    &#125; <br>&#125;<br><br>public class C extends B&#123;<br><br>&#125;<br><br>public class D extends B&#123;<br><br>&#125;<br><br>public class Test &#123;<br>    public static void main(String[] args) &#123;<br>        A a1 = new A();<br>        A a2 = new B();<br>        B b = new B();<br>        C c = new C();<br>        D d = new D();<br>        <br>        System.out.println(<span class="hljs-string">&quot;1--&quot;</span> + a1.show(b));<br>        System.out.println(<span class="hljs-string">&quot;2--&quot;</span> + a1.show(c));<br>        System.out.println(<span class="hljs-string">&quot;3--&quot;</span> + a1.show(d));<br>        System.out.println(<span class="hljs-string">&quot;4--&quot;</span> + a2.show(b));<br>        System.out.println(<span class="hljs-string">&quot;5--&quot;</span> + a2.show(c));<br>        System.out.println(<span class="hljs-string">&quot;6--&quot;</span> + a2.show(d));<br>        System.out.println(<span class="hljs-string">&quot;7--&quot;</span> + b.show(b));<br>        System.out.println(<span class="hljs-string">&quot;8--&quot;</span> + b.show(c));<br>        System.out.println(<span class="hljs-string">&quot;9--&quot;</span> + b.show(d));      <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上每A，B，C类都有一个show方法。如果我们执行上面代码，会发现输出的结果会由于创建的类不同而不同。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">1--A and A<br>2--A and A<br>3--A and D<br>4--B and A<br>5--B and A<br>6--A and D<br>7--B and B<br>8--B and B<br>9--A and D<br></code></pre></td></tr></table></figure><p>但是第四行为什么输出的不是“B AND B”呢。因为a2调用show方法的对象的静态类型是A，其次静态类型的参数是B。在A类中最匹配的方法是 <span class="label label-info">public String show(A obj)</span>。但是如果调用了A类的该方法，那么输出应该是”A and A”。 所以另一个原因是，我们可以在B类中找到一个更加具体的方法。更具体的方法的定义：<span class="label label-info">function(type1_1 p1, …, type1_n pn)比function(type2_1 p2, …, type2_n pn)更加具体，当且仅当对有所有的i，1$\leqslant$i$\leqslant$n,type1_i是type2_i的子类。</span></p><p>在上面这种静态类型和动态类型不一致的情况下，编译器会对静态类型的类里面的方法进行以下检索：</p><ol><li>检查在静态类型的类中是否有该函数</li> <li>检测是否有多个签名匹配(子类是否重写该方法)</li><li>返回最具体最匹配的方法</li></ol><p>如果静态类型和动态类型一致，那么就会有以下的调用顺序：<span class="label label-info">this.show(O)、super.show(O)、this.show((super)O)、super.show((super)O)。</span></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>多态的最重要的条件是方法的重写，而<span class="label label-info">重写</span>又离不开<span class="label label-info">继承</span>。所以要实现多态必定有<span class="label label-info">继承</span>和<span class="label label-info">重写</span>这两个技术。</p><p>如果发现错误请留言告知，万分感谢。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><ol><a href="https://programmation-orientee-objet.pages.ensimag.fr/poo/resources/fiches/01-ClassesEtObjets/">学校资料</a></ol><ol><a href="https://www.cnblogs.com/chenssy/p/3372798.html">Java技术驿站</a></ol></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>继承</title>
    <link href="/2021/12/30/%E7%BB%A7%E6%89%BF/"/>
    <url>/2021/12/30/%E7%BB%A7%E6%89%BF/</url>
    
    <content type="html"><![CDATA[<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>继承可以让子类拥有父类的所有非private的方法和属性，并且子类可以在父类的基础上添加<br>自己特有的方法和属性。可以简单的理解为，继承让父类变得更加特殊，可以描述的范围更窄。</p><p>我们假设交通工具是一个父类，那么我们可以创建一些子类如：飞机，汽车，轮船。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs bash">public class Vehicle &#123;<br>    private String id;<br>    private String destination;<br>    private int passenger;<br><br>    public Vehicle(String id, String destination, int passenger)<br>    &#123;<br>        this.id = id;<br>        this.setDestination(destination);<br>        this.setPassenger(passenger);<br>    &#125;<br><br>    public void way()//如何去目的地<br>    &#123;<br>        System.out.printf(<span class="hljs-string">&quot;tele-transmit&quot;</span>);<br>    &#125;<br><br><br>    //----------------------GETTER/SETTER------------------------<br>    public String <span class="hljs-function"><span class="hljs-title">getDestination</span></span>() &#123;<br>        <span class="hljs-built_in">return</span> destination;<br>    &#125;<br><br>    public void setDestination(String destination) &#123;<br>        this.destination = destination;<br>    &#125;<br><br>    public int <span class="hljs-function"><span class="hljs-title">getPassenger</span></span>() &#123;<br>        <span class="hljs-built_in">return</span> passenger;<br>    &#125;<br><br>    public void setPassenger(int passenger) &#123;<br>        this.passenger = passenger;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p></p><p>拿子类飞机为例，他肯定是要有父类的所有属性，并且我们可以根据飞机的特运输特性，给他添加一个新的属性：飞行高度。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">public class Plane extends Vehicle&#123;<br>    private int altitude;<br><br>    public Plane(String id, String destination, int passenger,int altitude) &#123;<br>        super(id, destination, passenger);<br>        this.altitude = altitude;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li> <span class="label label-info">extends</span>是继承的关键字。</li><li> Java 不允许多继承。一个子类只有一个父类，正如每个人只有一个die。</li><li> <span class="label label-info">super</span>是调用父类属性或方法的关键字。</li><li> 如果在子类要调用父类构造方法，super()一定要放子类构造方法的第一行。</li><li> 子类拥有父类所有非private的方法和属性</li></ul><p></p><h3 id="重定义方法-重写方法"><a href="#重定义方法-重写方法" class="headerlink" title="重定义方法/重写方法"></a>重定义方法/重写方法</h3><p>本身Vehicle有如何去到目的地的方法way()，但是飞机应该是飞去目的地而不是传送过去，<br>所以我们需要在子类重新定义这个方法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash">public class Plane extends Vehicle&#123;<br>    private int altitude;<br><br>    public Plane(String id, String destination, int passenger,int altitude) &#123;<br>        super(id, destination, passenger);<br>        this.altitude = altitude;<br>    &#125;<br>    <br>    @Override<br>    public void <span class="hljs-function"><span class="hljs-title">way</span></span>()<br>    &#123;<br>        System.out.println(<span class="hljs-string">&quot;id: &quot;</span> + super.getId() + <span class="hljs-string">&quot; fly fly fly!&quot;</span>);<br>        //或者我们可以飞到一半再传送<br>        //super.way();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">public class Test&#123;<br>    public static void main(String[] args) &#123;<br>        Vehicle v = new Vehicle(<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;beiking&quot;</span>,1);<br>        Plane f = new Plane(<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;shanghai&quot;</span>,200,20000);<br><br>        v.way();//id: 1 tele-transmit<br>        f.way();//id: 2 fly fly fly!<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li> <span class="label label-info">@Override</span>是重写的关键字。</li><li> 重写的方法必须拥有相同的函数名，返回值，对应的参数类型和个数。</li><li> 重写和重载<span class="label label-info">@Overload</span>不同，重载是给类多加了一个新方法，因为方法的参数数量和类型不同，而重写是同一个方法内容不同。</li></ul><p></p><h3 id="构造方法及调用顺序"><a href="#构造方法及调用顺序" class="headerlink" title="构造方法及调用顺序"></a>构造方法及调用顺序</h3><p>如果子类没有自己的构造方法，那么他会调用父类的构造方法。因为默认调用父类的无参构造方法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">public class Plane extends Vehicle&#123;<br><br>    //如果没有构造方法，系统添加如下构造方法<br>    public <span class="hljs-function"><span class="hljs-title">Plane</span></span>() &#123;<br>        super();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>所以当我们新建一个子类plane，他会首先调用Plane的构造方法，然后因为Plane（）的第一行是super()，所以会调用对应的父类Vehicle的构造方法。<br>而执行顺行是先执行Vehicle的构造方法，再执行Plane的构造方法。原理如同递归函数的调用与执行。</p><p></p>### 超类 ObjectObject是所有类的父类（所以称其为超类）。原因在于所有没有extends关键字的类(如Vehicle)，都默认继承了Object类。所以即使子类(Plane)没有直接继承Object类，但是间接继承了Object类的属性和方法。Object类主要方法如下：<ul><li> <span class="label label-info">public String toString()</span>以字符串的形式返回对象信息。</li><li> <span class="label label-info">public boolean equals(Object obj)</span>如果不重写此方法，那么系统会拿两个对象的地址进行比较。</li><li> <span class="label label-info">public int hashCode() </span>如果重写了equals()方法，此方法也要重写，以免在用hash表的时候出现hashcode相同而出现问题(后面会有文章解释，为什么不用重写hashCode()，hash表也不会出问题)。</li></ul><p></p><h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><p>被<span class="label label-info">final</span>修饰的方法不能被重写。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">public class Vehicle &#123;<br><br>    public final void way()//如何去目的地<br>    &#123;<br>        System.out.printf(<span class="hljs-string">&quot;tele-transmit&quot;</span>);<br>    &#125;<br>&#125;<br><br>public class Plane extends Vehicle&#123;<br>    //无法重写<br>&#125;<br><br></code></pre></td></tr></table></figure><p>如果发现错误请留言告知，万分感谢。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><ol><a href="https://programmation-orientee-objet.pages.ensimag.fr/poo/resources/fiches/03-Heritage/">学校资料</a></ol></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>类和对象</title>
    <link href="/2021/12/27/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/"/>
    <url>/2021/12/27/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="类-Class"><a href="#类-Class" class="headerlink" title="类(Class)"></a>类(Class)</h2><p>类是一类对象的模板。<br>类包含对象的属性和方法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash">public class Person<br>&#123;<br>    String name;<br>    int age;<br>    <br>    void <span class="hljs-function"><span class="hljs-title">learn</span></span>()<br>    &#123;<br>      System.out.println(<span class="hljs-string">&quot;learn sth&quot;</span>);<br>    &#125;<br>    <br>    void <span class="hljs-function"><span class="hljs-title">eat</span></span>()<br>    &#123;<br>      System.out.println(<span class="hljs-string">&quot;eat sth&quot;</span>);<br>    &#125;<br>    <br>    void <span class="hljs-function"><span class="hljs-title">sleep</span></span>()<br>    &#123;<br>      System.out.println(<span class="hljs-string">&quot;zzzzzzz&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="对象-Object"><a href="#对象-Object" class="headerlink" title="对象(Object)"></a>对象(Object)</h2><p>对象是一个类的实例，有该对象特有的属性和方法。</p><p><img src="/img/java/exemple.png"></p><p>如上图，人（Person）是一个类，而小明是人这个类的一个对象，<br>小红是人这个类的另一个对象。每个对象有各自的名字和各自的年龄。<br>生成对象的这个动作，我们称为实例化。</p><h2 id="类的声明与初始化"><a href="#类的声明与初始化" class="headerlink" title="类的声明与初始化"></a>类的声明与初始化</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">Person xiaoMin, xiaoHong; //对象的声明 <br>xiaoMin = new Person(); //对象的实例化<br></code></pre></td></tr></table></figure><ul><li>在对象声明的时候，这个内存的值一般是null。</li> <li> 在对象实例化的时候，才会对对象进行进行内存分配</li><li> <span class="label label-info">new</span>是创建对象的关键字</li></ul><h2 id="访问控制修饰符"><a href="#访问控制修饰符" class="headerlink" title="访问控制修饰符"></a>访问控制修饰符</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">public class Person<br>&#123;<br>    private String name;<br>    private int age;<br>    <br>    public String <span class="hljs-function"><span class="hljs-title">getName</span></span>()<br>    &#123;<br>      <span class="hljs-built_in">return</span> this.name;<br>    &#125;<br>    public void setName(String name)<br>    &#123;<br>      this.name = name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><table class="table table-striped table-hover"><tr><th></th><th>其他包的类</th><th>子类</th><th>同包其他类</th><th>内部类</th></tr><tr><th>public(+)</th><th><em style="color: green;">✔</th><th><em style="color: green;">✔</th><th><em style="color: green;">✔</th><th><em style="color: green;">✔</th></tr><tr><th>protected(#)</th><th><em style="color: red;">✘</th><th><em style="color: green;">✔</th><th><em style="color: green;">✔</th><th><em style="color: green;">✔</th></tr><tr><th>defalut()</th><th><em style="color: red;">✘</th><th><em style="color: red;">✘</th><th><em style="color: green;">✔</th><th><em style="color: green;">✔</th></tr><tr><th>private(-)</th><th><em style="color: red;">✘</th><th><em style="color: red;">✘</th><th><em style="color: red;">✘</th><th><em style="color: green;">✔</th></tr></table><ul><li>包，可以理解为同目录下的不同文件夹</li><li><span class="label label-info">this.</span>为了调用本类的属性,以便于区分方法内的类属性和传入参数</li><li><span class="label label-info">public</span>一般用于修饰方法，如上用于getName和setName</li><li><span class="label label-info">protected</span>一般是修饰父类的属性，以便于子类能够直接使用父类属性</li><li><span class="label label-info">default</span>如果不对属性添加修饰符，系统则会给他一个默认修饰符。</li><li><span class="label label-info">private</span>用来保护数据和隐藏类，因为被private修饰的只能被所属类访问。</li></ul><p class="note note-danger">要求：类的所有属性必须被private修饰。（个人觉得父类的方法可以用protected修饰）</p><h2 id="Getter和Setter"><a href="#Getter和Setter" class="headerlink" title="Getter和Setter"></a>Getter和Setter</h2><p>当一个另一类无法访问此类的私有属性。我们可以用getter来获取此属性的值，用setter来修改属性的值。</p><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs bash">public class Person<br>&#123;<br>    private String name;<br>    private int age;<br>    <br>    //----------------Construire------------------<br>    public Person(String name)<br>    &#123;<br>      this(name,18);//调用下面那个构造方法，age默认为18岁<br>    &#125;<br>    <br>    public Person(String name, int age)<br>    &#123;<br>      this.name = name;<br>      this.age = age;<br>    &#125;<br>    <br>    public Person(int age)<br>    &#123;<br>      this(<span class="hljs-string">&quot;???&quot;</span>,age);//调用上面那个构造方法，无名氏<br>    &#125;<br>    <br>    //-----------------GETTER-------------<br>    public String <span class="hljs-function"><span class="hljs-title">getName</span></span>()<br>    &#123;<br>      <span class="hljs-built_in">return</span> this.name;<br>    &#125;<br>    //-----------------SETTER-------------<br>    public void setName(String name)<br>    &#123;<br>      this.name = name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">public class TestPerson &#123;<br>    public static void main(String[] args) &#123;<br>        Person xiaoHong = new Person(<span class="hljs-string">&quot;xiao hong&quot;</span>); //调用上面第一个构造方法<br>        Person xiaoMing = new Person(<span class="hljs-string">&quot;xiao ming&quot;</span> ,18);//调用上面第二个构造方法<br><br>        System.out.println(xiaoHong);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>构造方法没有返回值。</li> <li>一般方法名字开头必须小写，但是构造方法例外，因为构造方法的名字<b>必须</b>是类名。</li><li>构造方法可以有多个(参数数量或参数类型不同)，每次<span class="label label-info">new</span>一个对象调用的构造方法是根据传入参数的数量来决定的。</li><li>如果一个类没有写构造方法，那么他会调用他顶级父类个<a href="https://docs.oracle.com/javase/8/docs/api/java/util/Objects.html">Object</a>的构造方法。</li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/Objects.html">Object</a>是所有类的父类。(这是个Object类不是上面说的对象)</li></ul><p>当我们使用<span class="label label-info">new</span>的时候的jvm的操作顺序。</p><ul><ol>为该对象租用内存地址。</ol><ol>为对象中的属性赋值，如果没有指定值就给一个<span class="label label-success">默认值</span>。</ol><ol>调用对应的构造方法。</ol></ul><p><span class="label label-success">默认值</span>整型默认为<span class="label label-info">0</span>，浮点型默认为<span class="label label-info">0.0</span>，布尔类型默认为<span class="label label-info">false</span>，所有对象的默认类型是<span class="label label-info">null</span>,构造方法是jvm赋予默认值之后才被调用。</p><h2 id="主方法"><a href="#主方法" class="headerlink" title="主方法"></a>主方法</h2><p>主方法（<span class="label label-info">main</span>）是程序启动的入口，如上面的TestPerson的main是我们运行TestPerson的入口。而且有主方法的类<b>必须</b>被public修饰。</p><h2 id="toString-方法"><a href="#toString-方法" class="headerlink" title="toString()方法"></a>toString()方法</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">public class Person<br>&#123;<br>   //照上<br>  <br>    @Override<br>    public String <span class="hljs-function"><span class="hljs-title">toString</span></span>() &#123;<br>        <span class="hljs-built_in">return</span> <span class="hljs-string">&quot;i&#x27;m &quot;</span> + this.name + <span class="hljs-string">&quot; and &quot;</span> + this.age + <span class="hljs-string">&quot; years old&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果类没有写toString()方法，则系统会调用Objectt的toString()方法，此时在控制台会显示一串十六进制的地址。<br>而这个地址指向的就是我们的toString()方法。所以如果我们写了此方法，控制台就会返回对应的信息。</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>java TestPerson <br>Person<span class="hljs-variable">@14dad5dc</span><br><br><span class="hljs-variable">$ </span>javac TestPerson.java<br><span class="hljs-variable">$ </span>java TestPerson <br>i<span class="hljs-string">&#x27;m xiao hong and 18 years old</span><br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一个非Test类一般包含他的属性和方法，如构造方法用于创建对象，Getter和Setter用于访问和修改属性，toString()用于输出信息。而Test类一般不包含属性，只有一个主函数来启动我们的程序。</p><p>如果发现错误请留言告知，万分感谢。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><ol><a href="https://programmation-orientee-objet.pages.ensimag.fr/poo/resources/fiches/01-ClassesEtObjets/">学校资料</a></ol></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>异常处理</title>
    <link href="/2021/01/01/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <url>/2021/01/01/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>Java异常有两大类，分别是失控异常和可控异常。失控异常一般指的是错误(<span class="label label-info">java.lang.Error</span>)<br>和运行时异常(<span class="label label-info">java.lang.RuntimeException</span>)。<br>可控异常一般指的是检查性异常<span class="label label-info">java.lang.Execption</span>。在别的文档是直接把错误归一类，异常归一类，然后再讨论运行时异常和检查性异常。</p><p><img src="/img/java/exception.svg"></p><h3 id="Throwable类"><a href="#Throwable类" class="headerlink" title="Throwable类"></a>Throwable类</h3><p>Throwable是所有异常的父类，他拥有的主要方法如下：</p><ul><li><span class="label label-info">public String getMessage()</span>在Throwable类中已经初始化，返回异常的详细信息。</li><li><span class="label label-info">    public Throwable getCause()</span>返回异常的原因。</li><li><span class="label label-info">    public String toString()</span>返回异常尖端描述</li><li><span class="label label-info">    public void printStackTrace()</span>将此throwable和他的回溯输出到standard error</li><li><span class="label label-info">    public StackTraceElement [] getStackTrace()</span>返回一个包含堆栈层次的数组。下标为0的元素代表栈顶，最后一个元素代表方法调用堆栈的栈底。</li></ul><h3 id="捕获或抛出自己的异常类"><a href="#捕获或抛出自己的异常类" class="headerlink" title="捕获或抛出自己的异常类"></a>捕获或抛出自己的异常类</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs bash">//同一文件中，只准有一个public类<br>class PassengerIncorrectException extends Exception &#123;<br>    public PassengerIncorrectException(String message) &#123;<br>        super(message);<br>    &#125;<br>&#125;<br>public class Vehicle &#123;<br>    private String id;<br>    private String destination;<br>    private int passenger;<br><br>    public Vehicle(String id, String destination, int passenger)<br>    &#123;<br>        this.id = id;<br>        this.setDestination(destination);<br>        this.setPassenger(passenger);<br>    &#125;<br><br>    public void <span class="hljs-function"><span class="hljs-title">way</span></span>()<br>    &#123;<br>        System.out.println(<span class="hljs-string">&quot;id: &quot;</span> +this.id + <span class="hljs-string">&quot; tele-transmit&quot;</span>);<br>    &#125;<br><br><br>    //----------------------GETTER/SETTER------------------------<br>    public String <span class="hljs-function"><span class="hljs-title">getDestination</span></span>() &#123;<br>        <span class="hljs-built_in">return</span> destination;<br>    &#125;<br><br>    public void setDestination(String destination) &#123;<br>        this.destination = destination;<br>    &#125;<br><br>    public int <span class="hljs-function"><span class="hljs-title">getPassenger</span></span>() &#123;<br>        <span class="hljs-built_in">return</span> passenger;<br>    &#125;<br><br><br>    //捕获异常<br>    public void setPassenger(int passenger) &#123;<br>        try &#123;<br>            <span class="hljs-keyword">if</span> (passenger &lt; 0) &#123;<br>                throw new PassengerIncorrectException(<span class="hljs-string">&quot;passenger &lt; 0 !!!!&quot;</span>);<br>            &#125;<br>        &#125;catch (PassengerIncorrectException e)//必须精确声明异常类<br>        &#123;<br>            System.out.println(e);<br>            e.printStackTrace();<br>            System.exit(1); //让程序退出执行<br>        &#125; finally &#123;<br>            System.out.printf(<span class="hljs-string">&quot;setPassenger finlay&quot;</span>);<br>        &#125;<br>    <br><br>        this.passenger = passenger;<br>    &#125;<br>  <br>    //或者抛出异常<br>     public void setPassenger(int passenger) throws PassengerIncorrectException &#123;<br>            <span class="hljs-keyword">if</span> (passenger &lt; 0) &#123;<br>                throw new PassengerIncorrectException(<span class="hljs-string">&quot;passenger &lt; 0 !!!!&quot;</span>);<br>        this.passenger = passenger;<br>    &#125;<br><br><br>    public String <span class="hljs-function"><span class="hljs-title">getId</span></span>() &#123;<br>        <span class="hljs-built_in">return</span> id;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li>在同一文件中，只准有一个public类</li> <li>异常<b>必须</b>被抛出<span class="label label-info">throws</span><b>或者</b>被捕获</li><li>必须要用<span class="label label-info">try...catch...</span>来捕获抛出的异常</li><li>在catch必须精确的声明的异常类，不能用Exception敷衍，如果同时有多个不同异常，可以用多个catch分别捕获</li><li>无论是否发生异常，<span class="label label-info">finally</span>代码块中的代码总会被执行。</li></ul><h3 id="异常执行顺序"><a href="#异常执行顺序" class="headerlink" title="异常执行顺序"></a>异常执行顺序</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs bash">class NbEcaillesIncorrectException extends Exception &#123;<br>    public <span class="hljs-function"><span class="hljs-title">NbEcaillesIncorrectException</span></span>() &#123;<br>        super();<br>    &#125;<br>&#125;<br><br>class NbMaxPangolinException extends Exception &#123;<br>    public <span class="hljs-function"><span class="hljs-title">NbMaxPangolinException</span></span>() &#123;<br>        super(<span class="hljs-string">&quot;Le nombre maximal de pangolins est atteint...&quot;</span>);<br>    &#125;<br>&#125;<br><br>class NommageException extends Exception &#123;<br>    public <span class="hljs-function"><span class="hljs-title">NommageException</span></span>() &#123;<br>        super();<br>    &#125;<br>&#125;<br>class CanardException extends Exception &#123;<br>    public <span class="hljs-function"><span class="hljs-title">CanardException</span></span>() &#123;<br>        super();<br>    &#125;<br>&#125;<br><br>class PangolinException extends Exception &#123;<br>    public <span class="hljs-function"><span class="hljs-title">PangolinException</span></span>() &#123;<br>        super();<br>    &#125;<br>&#125;<br><br>public class TestC &#123;<br>    private static final boolean PANGOLIN_EXCEPTION = <span class="hljs-literal">false</span>;<br>    private static final boolean NOMMAGE_EXCEPTION = <span class="hljs-literal">false</span>;<br>    private static final boolean CANARD_EXCEPTION = <span class="hljs-literal">false</span>;<br>    private static final boolean NBECAILLESINCORRECT_EXCEPTION = <span class="hljs-literal">false</span>;<br>    private static final boolean NBMAXPANGOLIN_EXCEPTION = <span class="hljs-literal">true</span>;<br>    private static final boolean ARITHMETIC_EXCEPTION = <span class="hljs-literal">false</span>;<br>    private static final boolean ILLEGAL_ARGUMENT_EXCEPTION = <span class="hljs-literal">false</span>;<br><br>    public static void m1() throws CanardException &#123;<br>        try &#123;<br>            System.out.println(<span class="hljs-string">&quot;Début de m1()&quot;</span>);<br>            m2();<br>            System.out.println(<span class="hljs-string">&quot;Fin de m1()&quot;</span>);<br>        &#125; catch (PangolinException e) &#123;<br>            System.out.println(<span class="hljs-string">&quot;Exception Pangolin (de m1()).&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    public static void m2() throws PangolinException, CanardException &#123;<br>        try &#123;<br>            System.out.println(<span class="hljs-string">&quot;Début de m2()&quot;</span>);<br>            m3();<br>            System.out.println(<span class="hljs-string">&quot;Fin de m2()&quot;</span>);<br>        &#125; catch (NbMaxPangolinException e) &#123;<br>            System.out.println(<span class="hljs-string">&quot;Exception nombre max pangolin (de m2()).&quot;</span>);<br>            throw new IllegalArgumentException();<br>        &#125; finally &#123;<br>            System.out.println(<span class="hljs-string">&quot;Finally de m2()&quot;</span>);<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;Fin de m2() après le try/catch/finally&quot;</span>);<br>    &#125;<br><br>    public static void m3() throws PangolinException, CanardException,NbMaxPangolinException &#123;<br>        try &#123;<br>            System.out.println(<span class="hljs-string">&quot;Début de m3()&quot;</span>);<br>            <span class="hljs-keyword">if</span> (PANGOLIN_EXCEPTION)<br>                throw new PangolinException();<br>            <span class="hljs-keyword">if</span> (NOMMAGE_EXCEPTION)<br>                throw new NommageException();<br>            <span class="hljs-keyword">if</span> (CANARD_EXCEPTION)<br>                throw new CanardException();<br>            <span class="hljs-keyword">if</span> (NBECAILLESINCORRECT_EXCEPTION)<br>                throw new NbEcaillesIncorrectException();<br>            <span class="hljs-keyword">if</span> (NBMAXPANGOLIN_EXCEPTION)<br>                throw new NbMaxPangolinException();<br>            <span class="hljs-keyword">if</span> (ARITHMETIC_EXCEPTION)<br>                throw new ArithmeticException();<br>            <span class="hljs-keyword">if</span> (ILLEGAL_ARGUMENT_EXCEPTION)<br>                throw new IllegalArgumentException();<br>            System.out.println(<span class="hljs-string">&quot;Fin de m3()&quot;</span>);<br>        &#125; catch (NommageException | NbEcaillesIncorrectException e) &#123;<br>            System.out.println(<span class="hljs-string">&quot;Exception Nommage (de m3()).&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    public static void main(String[] args) throws CanardException &#123;<br>        System.out.println(<span class="hljs-string">&quot;Début de la méthode principale&quot;</span>);<br>        m1();<br>        System.out.println(<span class="hljs-string">&quot;Fin de la méthode principale&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面是老师给的例子，可以通过修改常量的真值来测试。</p><ul><li>抛出的异常会一直回溯，直到被捕捉。异常被处理之后，程序继续运行。</li><li>如果抛出的异常最终<b>没有</b>被捕捉，那么程序会被中止。</li><li>如果try，catch内<b>没有</b>return语句，那么执行顺序是 try{} catch(){}finally{} return;</li><li>如果try，catch内<b>有</b>return语句，在return之前，如果finally存在的话，都会先执行finally语句，最后再return。</li><li>如果finally中有return语句，那么程序就在finally被返回,所以finally中的return是一定会被return的。</li><li>因为在执行finally之前，reutrn语句已经开始执行，所以在finally内修改返回值是无用的(如果finally没return)。</li></ul><p>如果发现错误请留言告知，万分感谢。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><ol><a href="https://programmation-orientee-objet.pages.ensimag.fr/poo/resources/fiches/04-Exceptions/">学校资料</a></ol><ol><a href="https://blog.csdn.net/xx326664162/article/details/50266995">薛瑄的博客</a></ol><ol><a href="https://www.runoob.com/java/java-exceptions.html">菜鸟教程</a></ol></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>

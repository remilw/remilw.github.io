<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>继承</title>
    <link href="/2021/12/30/%E7%BB%A7%E6%89%BF/"/>
    <url>/2021/12/30/%E7%BB%A7%E6%89%BF/</url>
    
    <content type="html"><![CDATA[<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>继承可以让子类拥有父类的所有非private的方法和属性，并且子类可以在父类的基础上添加<br>自己特有的方法和属性。可以简单的理解为，继承让父类变得更加特殊，可以描述的范围更窄。</p><p>我们假设交通工具是一个父类，那么我们可以创建一些子类如：飞机，汽车，轮船。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs bash">public class Vehicle &#123;<br>    private String id;<br>    private String destination;<br>    private int passenger;<br><br>    public Vehicle(String id, String destination, int passenger)<br>    &#123;<br>        this.id = id;<br>        this.setDestination(destination);<br>        this.setPassenger(passenger);<br>    &#125;<br><br>    public void way()//如何去目的地<br>    &#123;<br>        System.out.printf(<span class="hljs-string">&quot;tele-transmit&quot;</span>);<br>    &#125;<br><br><br>    //----------------------GETTER/SETTER------------------------<br>    public String <span class="hljs-function"><span class="hljs-title">getDestination</span></span>() &#123;<br>        <span class="hljs-built_in">return</span> destination;<br>    &#125;<br><br>    public void setDestination(String destination) &#123;<br>        this.destination = destination;<br>    &#125;<br><br>    public int <span class="hljs-function"><span class="hljs-title">getPassenger</span></span>() &#123;<br>        <span class="hljs-built_in">return</span> passenger;<br>    &#125;<br><br>    public void setPassenger(int passenger) &#123;<br>        this.passenger = passenger;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p></p><p>拿子类飞机为例，他肯定是要有父类的所有属性，并且我们可以根据飞机的特运输特性，给他添加一个新的属性：飞行高度。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">public class Plane extends Vehicle&#123;<br>    private int altitude;<br><br>    public Plane(String id, String destination, int passenger,int altitude) &#123;<br>        super(id, destination, passenger);<br>        this.altitude = altitude;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li> <span class="label label-info">extends</span>是继承的关键字。</li><li> Java 不允许多继承。一个子类只有一个父类，正如每个人只有一个die。</li><li> <span class="label label-info">super</span>是调用父类属性或方法的关键字。</li><li> 如果在子类要调用父类构造方法，super()一定要放子类构造方法的第一行。</li><li> 子类拥有父类所有非private的方法和属性</li></ul><p></p>### 重定义方法/重写方法本身Vehicle有如何去到目的地的方法way()，但是飞机应该是飞去目的地而不是传送过去，所以我们需要在子类重新定义这个方法。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash">public class Plane extends Vehicle&#123;<br>    private int altitude;<br><br>    public Plane(String id, String destination, int passenger,int altitude) &#123;<br>        super(id, destination, passenger);<br>        this.altitude = altitude;<br>    &#125;<br>    <br>    @Override<br>    public void <span class="hljs-function"><span class="hljs-title">way</span></span>()<br>    &#123;<br>        System.out.println(<span class="hljs-string">&quot;id: &quot;</span> + super.getId() + <span class="hljs-string">&quot; fly fly fly!&quot;</span>);<br>        //或者我们可以飞到一半再传送<br>        //super.way();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">public class Test&#123;<br>    public static void main(String[] args) &#123;<br>        Vehicle v = new Vehicle(<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;beiking&quot;</span>,1);<br>        Plane f = new Plane(<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;shanghai&quot;</span>,200,20000);<br><br>        v.way();//id: 1 tele-transmit<br>        f.way();//id: 2 fly fly fly!<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li> <span class="label label-info">@Override</span>是重写的关键字。</li><li> 重写的方法必须拥有相同的函数名，返回值，对应的参数类型和个数。</li><li> 重写和重载<span class="label label-info">@Overload</span>不同，重载是给类多加了一个新方法，因为方法的参数数量和类型不同，而重写是同一个方法内容不同。</li></ul><p></p>### 构造方法及调用顺序如果子类没有自己的构造方法，那么他会调用父类的构造方法。因为默认调用父类的无参构造方法。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">public class Plane extends Vehicle&#123;<br><br>    //如果没有构造方法，系统添加如下构造方法<br>    public <span class="hljs-function"><span class="hljs-title">Plane</span></span>() &#123;<br>        super();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>所以当我们新建一个子类plane，他会首先调用Plane的构造方法，然后因为Plane（）的第一行是super()，所以会调用对应的父类Vehicle的构造方法。而执行顺行是先执行Vehicle的构造方法，再执行Plane的构造方法。原理如同递归函数的调用与执行。<p></p>### 超类 ObjectObject是所有类的父类（所以称其为超类）。原因在于所有没有extends关键字的类(如Vehicle)，都默认继承了Object类。所以即使子类(Plane)没有直接继承Object类，但是间接继承了Object类的属性和方法。Object类主要方法如下：<ul><li> <span class="label label-info">public String toString()</span>以字符串的形式返回对象信息。</li><li> <span class="label label-info">public boolean equals(Object obj)</span>如果不重写此方法，那么系统会拿两个对象的地址进行比较。</li><li> <span class="label label-info">public int hashCode() </span>如果重写了equals()方法，此方法也要重写，以免在用hash表的时候出现hashcode相同而出现问题(后面会有文章解释，为什么不用重写hashCode()，hash表也不会出问题)。</li></ul><p></p>### final被<span class="label label-info">final</span>修饰的方法不能被重写。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">public class Vehicle &#123;<br><br>    public final void way()//如何去目的地<br>    &#123;<br>        System.out.printf(<span class="hljs-string">&quot;tele-transmit&quot;</span>);<br>    &#125;<br>&#125;<br><br>public class Plane extends Vehicle&#123;<br>    //无法重写<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><ol><a href="https://programmation-orientee-objet.pages.ensimag.fr/poo/resources/fiches/03-Heritage/">学校资料</a></ol></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>类和对象</title>
    <link href="/2021/12/27/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/"/>
    <url>/2021/12/27/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="类-Class"><a href="#类-Class" class="headerlink" title="类(Class)"></a>类(Class)</h2><p>类是一类对象的模板。<br>类包含对象的属性和方法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash">public class Person<br>&#123;<br>    String name;<br>    int age;<br>    <br>    void <span class="hljs-function"><span class="hljs-title">learn</span></span>()<br>    &#123;<br>      System.out.println(<span class="hljs-string">&quot;learn sth&quot;</span>);<br>    &#125;<br>    <br>    void <span class="hljs-function"><span class="hljs-title">eat</span></span>()<br>    &#123;<br>      System.out.println(<span class="hljs-string">&quot;eat sth&quot;</span>);<br>    &#125;<br>    <br>    void <span class="hljs-function"><span class="hljs-title">sleep</span></span>()<br>    &#123;<br>      System.out.println(<span class="hljs-string">&quot;zzzzzzz&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="对象-Object"><a href="#对象-Object" class="headerlink" title="对象(Object)"></a>对象(Object)</h2><p>对象是一个类的实例，有该对象特有的属性和方法。</p><p><img src="/img/java/exemple.png"></p><p>如上图，人（Person）是一个类，而小明是人这个类的一个对象，<br>小红是人这个类的另一个对象。每个对象有各自的名字和各自的年龄。<br>生成对象的这个动作，我们称为实例化。</p><h2 id="类的声明与初始化"><a href="#类的声明与初始化" class="headerlink" title="类的声明与初始化"></a>类的声明与初始化</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">Person xiaoMin, xiaoHong; //对象的声明 <br>xiaoMin = new Person(); //对象的实例化<br></code></pre></td></tr></table></figure><ul><li>在对象声明的时候，这个内存的值一般是null。</li> <li> 在对象实例化的时候，才会对对象进行进行内存分配</li><li> <span class="label label-info">new</span>是创建对象的关键字</li></ul><h2 id="访问控制修饰符"><a href="#访问控制修饰符" class="headerlink" title="访问控制修饰符"></a>访问控制修饰符</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">public class Person<br>&#123;<br>    private String name;<br>    private int age;<br>    <br>    public String <span class="hljs-function"><span class="hljs-title">getName</span></span>()<br>    &#123;<br>      <span class="hljs-built_in">return</span> this.name;<br>    &#125;<br>    public void setName(String name)<br>    &#123;<br>      this.name = name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><table class="table table-striped table-hover"><tr><th></th><th>其他包的类</th><th>子类</th><th>同包其他类</th><th>内部类</th></tr><tr><th>public(+)</th><th><em style="color: green;">✔</th><th><em style="color: green;">✔</th><th><em style="color: green;">✔</th><th><em style="color: green;">✔</th></tr><tr><th>protected(#)</th><th><em style="color: red;">✘</th><th><em style="color: green;">✔</th><th><em style="color: green;">✔</th><th><em style="color: green;">✔</th></tr><tr><th>defalut()</th><th><em style="color: red;">✘</th><th><em style="color: red;">✘</th><th><em style="color: green;">✔</th><th><em style="color: green;">✔</th></tr><tr><th>private(-)</th><th><em style="color: red;">✘</th><th><em style="color: red;">✘</th><th><em style="color: red;">✘</th><th><em style="color: green;">✔</th></tr></table><ul><li>包，可以理解为同目录下的不同文件夹</li><li><span class="label label-info">this.</span>为了调用本类的属性,以便于区分方法内的类属性和传入参数</li><li><span class="label label-info">public</span>一般用于修饰方法，如上用于getName和setName</li><li><span class="label label-info">protected</span>一般是修饰父类的属性，以便于子类能够直接使用父类属性</li><li><span class="label label-info">default</span>如果不对属性添加修饰符，系统则会给他一个默认修饰符。</li><li><span class="label label-info">private</span>用来保护数据和隐藏类，因为被private修饰的只能被所属类访问。</li></ul><p class="note note-danger">要求：类的所有属性必须被private修饰。（个人觉得父类的方法可以用protected修饰）</p><h2 id="Getter和Setter"><a href="#Getter和Setter" class="headerlink" title="Getter和Setter"></a>Getter和Setter</h2><p>当一个另一类无法访问此类的私有属性。我们可以用getter来获取此属性的值，用setter来修改属性的值。</p><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs bash">public class Person<br>&#123;<br>    private String name;<br>    private int age;<br>    <br>    //----------------Construire------------------<br>    public Person(String name)<br>    &#123;<br>      this(name,18);//调用下面那个构造方法，age默认为18岁<br>    &#125;<br>    <br>    public Person(String name, int age)<br>    &#123;<br>      this.name = name;<br>      this.age = age;<br>    &#125;<br>    <br>    public Person(int age)<br>    &#123;<br>      this(<span class="hljs-string">&quot;???&quot;</span>,age);//调用上面那个构造方法，无名氏<br>    &#125;<br>    <br>    //-----------------GETTER-------------<br>    public String <span class="hljs-function"><span class="hljs-title">getName</span></span>()<br>    &#123;<br>      <span class="hljs-built_in">return</span> this.name;<br>    &#125;<br>    //-----------------SETTER-------------<br>    public void setName(String name)<br>    &#123;<br>      this.name = name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">public class TestPerson &#123;<br>    public static void main(String[] args) &#123;<br>        Person xiaoHong = new Person(<span class="hljs-string">&quot;xiao hong&quot;</span>); //调用上面第一个构造方法<br>        Person xiaoMing = new Person(<span class="hljs-string">&quot;xiao ming&quot;</span> ,18);//调用上面第二个构造方法<br><br>        System.out.println(xiaoHong);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>构造方法没有返回值。</li> <li>一般方法名字开头必须小写，但是构造方法例外，因为构造方法的名字<b>必须</b>是类名。</li><li>构造方法可以有多个(参数数量或参数类型不同)，每次<span class="label label-info">new</span>一个对象调用的构造方法是根据传入参数的数量来决定的。</li><li>如果一个类没有写构造方法，那么他会调用他顶级父类个<a href="https://docs.oracle.com/javase/8/docs/api/java/util/Objects.html">Object</a>的构造方法。</li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/Objects.html">Object</a>是所有类的父类。(这是个Object类不是上面说的对象)</li></ul><p>当我们使用<span class="label label-info">new</span>的时候的jvm的操作顺序。</p><ul><ol>为该对象租用内存地址。</ol><ol>为对象中的属性赋值，如果没有指定值就给一个<span class="label label-success">默认值</span>。</ol><ol>调用对应的构造方法。</ol></ul><p><span class="label label-success">默认值</span>整型默认为<span class="label label-info">0</span>，浮点型默认为<span class="label label-info">0.0</span>，布尔类型默认为<span class="label label-info">false</span>，所有对象的默认类型是<span class="label label-info">null</span>,构造方法是jvm赋予默认值之后才被调用。</p><h2 id="主方法"><a href="#主方法" class="headerlink" title="主方法"></a>主方法</h2><p>主方法（<span class="label label-info">main</span>）是程序启动的入口，如上面的TestPerson的main是我们运行TestPerson的入口。而且有主方法的类<b>必须</b>被public修饰。</p><h2 id="toString-方法"><a href="#toString-方法" class="headerlink" title="toString()方法"></a>toString()方法</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">public class Person<br>&#123;<br>   //照上<br>  <br>    @Override<br>    public String <span class="hljs-function"><span class="hljs-title">toString</span></span>() &#123;<br>        <span class="hljs-built_in">return</span> <span class="hljs-string">&quot;i&#x27;m &quot;</span> + this.name + <span class="hljs-string">&quot; and &quot;</span> + this.age + <span class="hljs-string">&quot; years old&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果类没有写toString()方法，则系统会调用Objectt的toString()方法，此时在控制台会显示一串十六进制的地址。<br>而这个地址指向的就是我们的toString()方法。所以如果我们写了此方法，控制台就会返回对应的信息。</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>java TestPerson <br>Person<span class="hljs-variable">@14dad5dc</span><br><br><span class="hljs-variable">$ </span>javac TestPerson.java<br><span class="hljs-variable">$ </span>java TestPerson <br>i<span class="hljs-string">&#x27;m xiao hong and 18 years old</span><br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一个非Test类一般包含他的属性和方法，如构造方法用于创建对象，Getter和Setter用于访问和修改属性，toString()用于输出信息。而Test类一般不包含属性，只有一个主函数来启动我们的程序。</p><p>如果发现错误请留言告知，万分感谢。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><ol><a href="https://programmation-orientee-objet.pages.ensimag.fr/poo/resources/fiches/01-ClassesEtObjets/">学校资料</a></ol></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
